---
layout: post
title: "2026 Jan Week 04 학습 기록: Python 완료, 자료구조와 알고리즘 시작"
date: 2026-01-25 20:00:00 +0900
categories: Study
tags: [python, study, data-structures, algorithms]
---

## 학습 기간
2026년 1월 18일 ~ 2026년 1월 24일

## 학습 목표
- Python 기본 자료형과 제어문 마스터
- 고급 파이썬 기능 학습 (클로저, 데코레이터, 제너레이터)
- 정규표현식 활용
- 자료구조와 알고리즘 학습 시작

---

## 2026-01-18

### Chapter 02: 자료형

Python의 기본 자료형들을 학습했습니다.

**숫자형**
```python
# 정수형
a = 123
b = -178
c = 0

# 실수형
a = 1.2
b = -3.45

# 8진수와 16진수
a = 0o177  # 8진수
b = 0x8ff  # 16진수

# 복소수
a = 1+2j
b = 3-4J
```

**문자열**
```python
# 문자열 생성
"Hello World"
'Python is fun'
"""Life is too short, You need python"""
'''Life is too short, You need python'''

# 문자열 연산
head = "Python"
tail = " is fun!"
head + tail  # 'Python is fun!'
head * 2     # 'PythonPython'

# 문자열 인덱싱과 슬라이싱
a = "Life is too short, You need Python"
a[0]      # 'L'
a[-1]     # 'n'
a[0:4]    # 'Life'
a[19:]    # 'You need Python'
```

**리스트**
```python
# 리스트 생성
odd = [1, 3, 5, 7, 9]
a = [1, 2, 3, ['a', 'b', 'c']]

# 리스트 슬라이싱
a = [1, 2, 3, 4, 5]
a[0:2]  # [1, 2]

# 리스트 함수
a = [1, 2, 3]
a.append(4)      # [1, 2, 3, 4]
a.sort()         # 리스트 정렬
a.reverse()      # 리스트 뒤집기
a.index(3)       # 값의 위치 반환
a.insert(0, 4)   # 위치에 요소 삽입
a.remove(1)      # 첫 번째 값 삭제
a.pop()          # 마지막 요소 반환 및 삭제
a.count(1)       # 개수 세기
a.extend([5, 6]) # 리스트 확장
```

**튜플**
```python
# 튜플 생성
t1 = ()
t2 = (1,)
t3 = (1, 2, 3)
t4 = 1, 2, 3

# 튜플은 값을 변경할 수 없음 (immutable)
# t1[0] = 5  # 오류 발생
```

**딕셔너리**
```python
# 딕셔너리 생성
dic = {'name': 'pey', 'phone': '010-9999-1234', 'birth': '1118'}

# 딕셔너리 쌍 추가하기
a = {1: 'a'}
a[2] = 'b'
a['name'] = 'pey'

# 딕셔너리 요소 삭제하기
del a[1]

# 딕셔너리 함수
a.keys()     # 키 리스트
a.values()   # 값 리스트
a.items()    # 키, 값 쌍 얻기
a.clear()    # 모든 요소 삭제
a.get('name') # 키로 값 얻기
'name' in a  # 해당 키 존재 여부 확인
```

**집합**
```python
# 집합 생성
s1 = set([1, 2, 3])
s2 = set("Hello")

# 집합 연산
s1 & s2  # 교집합
s1 | s2  # 합집합
s1 - s2  # 차집합

# 집합 함수
s1.add(4)      # 값 1개 추가
s1.update([4, 5, 6])  # 값 여러 개 추가
s1.remove(2)   # 특정 값 제거
```

**불 자료형**
```python
a = True
b = False

# 불 연산
bool('python')  # True
bool('')        # False
bool([1, 2, 3]) # True
bool([])        # False
bool(0)         # False
bool(3)         # True
```

### Chapter 03: 제어문

**if문**
```python
# 기본 if문
money = True
if money:
    print("택시를 타고 가라")
else:
    print("걸어가라")

# elif 사용
money = 2000
if money >= 3000:
    print("택시를 타고 가라")
elif money >= 2000:
    print("버스를 타고 가라")
else:
    print("걸어가라")

# 조건 연산자
score = 70
message = "success" if score >= 60 else "failure"
```

**while문**
```python
# 기본 while문
treeHit = 0
while treeHit < 10:
    treeHit = treeHit + 1
    print("나무를 %d번 찍었습니다." % treeHit)
    if treeHit == 10:
        print("나무 넘어갑니다.")

# break와 continue
coffee = 10
while True:
    money = int(input("돈을 넣어 주세요: "))
    if money == 300:
        print("커피를 줍니다.")
        coffee = coffee - 1
    elif money > 300:
        print("거스름돈 %d를 주고 커피를 줍니다." % (money - 300))
        coffee = coffee - 1
    else:
        print("돈을 다시 돌려주고 커피를 주지 않습니다.")
    if coffee == 0:
        print("커피가 다 떨어졌습니다. 판매를 중지합니다.")
        break
```

**for문**
```python
# 기본 for문
test_list = ['one', 'two', 'three']
for i in test_list:
    print(i)

# range 함수
a = range(10)      # 0부터 10 미만
a = range(1, 11)   # 1부터 11 미만

# for와 range를 이용한 구구단
for i in range(2, 10):
    for j in range(1, 10):
        print(i*j, end=" ")
    print('')

# 리스트 내포
a = [1, 2, 3, 4]
result = [num * 3 for num in a]
# [3, 6, 9, 12]

# 조건을 포함한 리스트 내포
result = [num * 3 for num in a if num % 2 == 0]
# [6, 12]
```

### Chapter 04: 파이썬 입출력

**함수**
```python
# 함수 정의
def add(a, b):
    return a + b

# 매개변수 지정하여 호출
result = add(a=3, b=7)

# 여러 개의 입력값
def add_many(*args):
    result = 0
    for i in args:
        result = result + i
    return result

# 키워드 매개변수
def print_kwargs(**kwargs):
    print(kwargs)

# 함수의 결과값은 언제나 하나
def add_and_mul(a, b):
    return a+b, a*b  # 튜플로 반환

# 초기값 설정
def say_myself(name, age, man=True):
    print("나의 이름은 %s 입니다." % name)
    print("나이는 %d살입니다." % age)
    if man:
        print("남자입니다.")
    else:
        print("여자입니다.")

# lambda 함수
add = lambda a, b: a+b
result = add(3, 4)
```

**사용자 입출력**
```python
# 입력
a = input()
number = input("숫자를 입력하세요: ")

# 출력
print("life" "is" "too short")  # lifeistoo short
print("life"+"is"+"too short")  # lifeistoo short

# 줄바꿈 제거
for i in range(10):
    print(i, end=' ')

# 포매팅
number = 3
print(f"나는 사과를 {number}개 먹었다.")
```

**파일 입출력**
```python
# 파일 쓰기
f = open("새파일.txt", 'w')
for i in range(1, 11):
    data = "%d번째 줄입니다.\n" % i
    f.write(data)
f.close()

# 파일 읽기
f = open("새파일.txt", 'r')
line = f.readline()
f.close()

# with문 사용
with open("foo.txt", "w") as f:
    f.write("Life is too short, you need python")
```

---

## 2026-01-20

표준 라이브러리 학습. sys, pickle, os, shutil, glob, tempfile, time, calendar, random 등 다양한 모듈의 활용.

---

## 2026-01-21

### Chapter 05: 클래스

**클래스 기본**
```python
# 클래스 정의
class Calculator:
    def __init__(self):
        self.result = 0
    
    def add(self, num):
        self.result += num
        return self.result
    
    def sub(self, num):
        self.result -= num
        return self.result

# 클래스 사용
cal1 = Calculator()
cal2 = Calculator()

# 상속
class MoreCalculator(Calculator):
    def pow(self, n):
        self.result **= n
        return self.result

# 메서드 오버라이딩
class SafeCalculator(Calculator):
    def div(self, num):
        if num == 0:
            return 0
        else:
            self.result /= num
            return self.result
```

**모듈과 패키지**
```python
# 모듈 만들기
# mod1.py
def add(a, b):
    return a + b

def sub(a, b):
    return a - b

# 모듈 사용
import mod1
print(mod1.add(3, 4))

from mod1 import add
print(add(3, 4))

# 패키지
# game/
#   __init__.py
#   sound/
#     __init__.py
#     echo.py
#   graphic/
#     __init__.py
#     render.py

from game.sound import echo
echo.echo_test()
```

**예외 처리**
```python
# try-except
try:
    4 / 0
except ZeroDivisionError as e:
    print(e)

# finally
try:
    f = open('foo.txt', 'r')
except FileNotFoundError:
    print('파일이 없습니다.')
else:
    data = f.read()
    f.close()
finally:
    print('작업을 완료했습니다.')

# 예외 발생시키기
class Bird:
    def fly(self):
        raise NotImplementedError
```

알고리즘 학습을 위한 새 repository data-structures-algorithms-with-python을 생성함.

---

## 2026-01-22

### Chapter 07: 고급 주제

**클로저 (Closure)**
```python
# 클로저 기본
def calc():
    a = 3
    b = 5
    def mul_add(x):
        return a * x + b
    return mul_add

c = calc()
print(c(1))  # 8
print(c(2))  # 11

# 클로저를 사용하는 이유
class Calc:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def mul_add(self, x):
        return self.a * x + self.b

# 위 클래스 대신 클로저 사용 가능
def calc(a, b):
    def mul_add(x):
        return a * x + b
    return mul_add
```

**데코레이터 (Decorator)**
```python
# 데코레이터 기본
def simple_decorator(func):
    def wrapper():
        print("함수 시작")
        func()
        print("함수 끝")
    return wrapper

@simple_decorator
def hello():
    print("안녕하세요")

# 매개변수가 있는 데코레이터
def trace(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print(f'{func.__name__}({args}, {kwargs}) -> {result}')
        return result
    return wrapper

@trace
def add(a, b):
    return a + b
```

**이터레이터 (Iterator)**
```python
# 이터레이터 프로토콜
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.position = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.position >= len(self.data):
            raise StopIteration
        result = self.data[self.position]
        self.position += 1
        return result

# 사용
i = MyIterator([1, 2, 3])
print(next(i))  # 1
print(next(i))  # 2
```

**제너레이터 (Generator)**
```python
# 제너레이터 기본
def mygen():
    yield 'a'
    yield 'b'
    yield 'c'

g = mygen()
print(next(g))  # 'a'
print(next(g))  # 'b'

# 제너레이터 표현식
g = (x*x for x in range(10))

# 제너레이터 활용
def get_natural_number():
    n = 0
    while True:
        n += 1
        yield n
```

**타입 어노테이션 (Type Annotation)**
```python
# 변수 어노테이션
num: int = 1
name: str = "홍길동"

# 함수 어노테이션
def add(a: int, b: int) -> int:
    return a + b

# 복잡한 타입
from typing import List, Dict, Tuple

def process_items(items: List[int]) -> Dict[str, int]:
    return {"count": len(items)}
```

### Chapter 08: 정규 표현식

**정규 표현식 기본**
```python
import re

# 매치 확인
p = re.compile('[a-z]+')
m = p.match("python")

if m:
    print('Match found: ', m.group())
else:
    print('No match')

# search: 문자열 전체를 검색
m = p.search("3 python")

# findall: 모든 매칭 결과 반환
result = p.findall("life is too short")

# finditer: 반복 가능한 객체 반환
result = p.finditer("life is too short")
for r in result:
    print(r)
```

**메타 문자**
```python
# . : 줄바꿈 문자를 제외한 모든 문자
p = re.compile('a.b')

# * : 0번 이상 반복
p = re.compile('ca*t')

# + : 1번 이상 반복
p = re.compile('ca+t')

# ? : 0번 또는 1번
p = re.compile('ab?c')

# {m,n} : m부터 n번 반복
p = re.compile('ca{2}t')
p = re.compile('ca{2,5}t')
```

**그룹핑과 치환**
```python
# 그룹핑
p = re.compile('(\w+)\s+\d+[-]\d+[-]\d+')
m = p.search("park 010-1234-1234")
print(m.group(1))  # park

# 치환
p = re.compile('(blue|white|red)')
p.sub('colour', 'blue socks and red shoes')
# 'colour socks and colour shoes'

# 그룹 참조
p = re.compile(r'(\b\w+)\s+\1')
p.search('Paris in the the spring').group()
```

### data-structures-algorithms-with-python: Chapter 01-1 알고리즘 기초

알고리즘 학습을 시작함. 기본적인 문제 해결 구조 학습.

**최댓값 구하기**
```python
# 세 정수를 입력받아 최댓값 구하기
def get_max(a, b, c):
    max = a
    if b > max: max = b
    if c > max: max = c
    return max
```

**중앙값 구하기**
```python
# 세 정수의 중앙값(median) 구하기
def get_med(a, b, c):
    if a >= b:
        if b >= c:
            return b
        elif c >= a:
            return a
        else:
            return c
    elif a > c:
        return a
    elif b > c:
        return c
    else:
        return b
```

**조건문 분기**
```python
# 3개로 분기하는 조건문
number = int(input("정수를 입력하세요.: "))

if number == 1:
    print("A")
elif number == 2:
    print("B")
else:
    print("C")
```

---

## 2026-01-25

### data-structures-algorithms-with-python 계속

**반복문 최적화**

while문과 for문을 이용한 합 구하기:
```python
# 1부터 n까지 자연수의 합 - while문
n = int(input("자연수 n값을 입력하세요: "))
sum = 0
i = 1

while i <= n:
    sum += i
    i += 1

# 1부터 n까지 자연수의 합 - for문
sum = 0
for i in range(1, n + 1):
    sum += i

# 가우스의 덧셈 공식
result = n * (n + 1) // 2
```

**조건문 실행 횟수 최적화**

+와 -를 번갈아 출력하는 두 가지 방법:
```python
# 비효율적 방법: 매 반복마다 조건 확인
for i in range(n):
    if i % 2 == 0:
        print("+", end="")
    else:
        print("-", end="")

# 효율적 방법: 조건 확인 1번으로 감소
for i in range(n // 2):
    print("+-", end="")

if n % 2:
    print("+")
```

**직사각형 변의 길이 경우의 수**
```python
# 넓이가 주어진 직사각형의 가능한 변의 길이 나열
area = int(input("직사각형의 넓이를 입력하세요.: "))
max_length = int(area ** (1 / 2))

for i in range(1, max_length + 1):
    if area % i == 0:
        print(f"{i} * {area // i} = {area}")
```

**for-else 구문**
```python
# 10 ~ 99 사이의 난수 n개 생성, 13이 나오면 중단
import random

n = int(input("난수의 개수를 입력하세요.: "))

for i in range(n):
    r = random.randint(10, 99)
    print(r, end=" ")
    if r == 13: 
        print(", break.")
        break
else:
    # break 없이 정상 종료 시 실행
    print("모든 난수가 생성되었습니다.")
```

**continue문 최적화**
```python
# 비효율적: 매번 조건 확인
for i in range(1, 13):
    if i == 8:
        continue
    else:
        print(i, end=" ")

# 효율적: range 조합
for i in list(range(1, 8)) + list(range(9, 13)):
    print(i, end=" ")
```

---

## 이번 주 학습 요약

### 주요 학습 내용
1. **Python 기초 완성**: 자료형, 제어문, 함수, 파일 입출력
2. **객체지향 프로그래밍**: 클래스, 상속, 모듈, 패키지
3. **고급 Python**: 클로저, 데코레이터, 이터레이터, 제너레이터
4. **정규표현식**: 패턴 매칭, 그룹핑, 치환
5. **알고리즘 기초**: 조건문, 반복문, 효율성 개선

### 핵심 프로그래밍 패턴
- **자료형 활용**: 리스트, 딕셔너리, 튜플의 특성 이해
- **함수형 프로그래밍**: lambda, map, filter, 리스트 내포
- **클로저 패턴**: 함수 내부 함수로 상태 캡슐화
- **데코레이터 패턴**: 함수 기능 확장
- **제너레이터 패턴**: 메모리 효율적인 반복
- **알고리즘 최적화**: 불필요한 조건 비교 제거

### 다음 주 계획
- 자료구조 심화 학습 (스택, 큐, 재귀)
- 검색 알고리즘 학습
- 정렬 알고리즘 학습

---

## 참고 자료
- [python-programming-practice 저장소](https://github.com/dev-EthanJ/python-programming-practice)
- [data-structures-algorithms-with-python 저장소](https://github.com/dev-EthanJ/data-structures-algorithms-with-python)
- Do it! 점프 투 파이썬
- Do it! 자료구조와 함께 배우는 알고리즘 입문: 파이썬 편
