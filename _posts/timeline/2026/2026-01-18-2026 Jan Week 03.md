---
layout: post
title: "2026 Jan Week 03 학습 기록: C언어 완료, Python 시작"
date: 2026-01-18
categories: [timeline, 2026]
tags: [C언어, Pyhon, 점프투파이썬, 독하게시작하는C프로그래밍]
---

 > from `2026-01-11` to `2026-01-17`
 
 > "독하게 시작하는 C 프로그래밍" C언어 프로그래밍 연습 완료

 > "Do it! 점프 투 파이썬" 기반으로 python 프로그래밍 연습 시작

 > 3월 복학 전에 프로그래밍 감각 되살리기 및 기본과목 복습 목표
---

## 2026-01-12

### Chapter 11. 메모리와 포인터 (전반부)

**학습 내용**
- 포인터 기본 개념과 주소 연산자 `&`
- 간접 지정 연산자 `*`
- 포인터와 배열의 관계
- 동적 메모리 할당 (`malloc`, `calloc`, `realloc`, `free`)

**주요 개념**

**포인터의 본질**
```c
int x = 10;
int *ptr = &x;  // ptr은 x의 주소를 저장

printf("%d\n", x);      // 직접 지정: 10
printf("%d\n", *ptr);   // 간접 지정: 10
```

**포인터와 배열**
```c
int list[5] = {10, 20, 30, 40, 50};
int *ptr = list;  // 배열 이름은 주소 상수

// 다음은 모두 동일한 표현
list[0] == *(list + 0) == *ptr
list[2] == *(list + 2) == *(ptr + 2)

// 포인터 연산으로 문자열 길이 구하기
char *start = buffer;
while (*start != '\0') ++start;
int length = start - buffer;  // 주소 차이 = 길이
```

**동적 메모리 할당**
```c
// malloc: 할당만
int *list = (int *)malloc(sizeof(int) * 5);

// calloc: 할당 + 0으로 초기화
int *new_list = (int *)calloc(5, sizeof(int));

// realloc: 크기 재조정
new_list = (int *)realloc(new_list, sizeof(int) * 10);

// 반드시 해제
free(list);
free(new_list);
```

**메모리 조작 함수**
- `memset()`: 메모리 초기화
- `memcpy()`: 메모리 복사
- `memcmp()`: 메모리 비교

**문자열 함수**
- `strcmp()`: 문자열 비교 (내용 비교)
- `strstr()`: 문자열 검색
- `strcpy()`, `strcat()`: 문자열 복사/연결

**핵심 포인트**
- 배열 연산자 `[]`는 포인터 연산의 syntactic sugar
  ```c
  arr[i] == *(arr + i)
  &arr[i] == arr + i
  ```
- 문자열 비교 시 `==` 연산자는 주소 비교, `strcmp()` 사용 필수

---

### Chapter 12. 함수 응용

**학습 내용**
- Call by Value vs Call by Reference
- 함수 매개변수로 포인터 전달
- 재귀 함수 (Recursion)
- 문자열 처리 함수들
- 유틸리티 함수 (`atoi`, `atof`, `time`, `rand`)

**주요 개념**

**Call by Reference**
```c
void Swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void) {
    int x = 10, y = 20;
    Swap(&x, &y);  // x와 y가 실제로 교환됨
}
```

**배열/문자열 함수에서 크기 전달**
```c
// 매개변수가 포인터일 때는 크기도 함께 전달
void GetName(char *name, int size) {
    fgets(name, size, stdin);
}

// 동적 할당한 메모리를 반환
char* GetName(void) {
    char *name = (char *)calloc(32, sizeof(char));
    fgets(name, 32, stdin);
    return name;  // Caller에서 free() 필수!
}
```

**재귀 함수**
```c
int GetFactorial(int n) {
    if (n == 1) return 1;  // 종료 조건 필수
    return n * GetFactorial(n - 1);
}
```

**문자열 처리**
```c
// strcat: 문자열 끝을 찾기 위해 strlen() 내부 호출
strcat(path, "folder");  // 비효율적

// 개선: 끝 위치를 계속 추적
char* mystrcat(char *dst, char *src) {
    while (*dst != '\0') ++dst;
    while (*src != '\0') *dst++ = *src++;
    *dst = '\0';
    return dst;  // 끝 위치 반환
}
```

**유틸리티 함수**
```c
// 문자열 → 숫자 변환
int num = atoi("123");
double d = atof("3.14");

// 시간 관련
time_t t = time(NULL);
struct tm *time_data = localtime(&t);

// 난수 생성
srand((unsigned)time(NULL));  // 시드 설정
int random = rand() % 10;      // 0~9
```

**연습문제 하이라이트**
- 문자열 검색 함수 구현 (인덱스 반환)
- 가위바위보 게임 (난수 활용)
- 날짜 계산 프로그램

---

## 2026-01-13

### Chapter 13. 구조체와 공용체

**학습 내용**
- 구조체 선언, 정의, 초기화
- 구조체 배열과 포인터
- 구조체를 매개변수/반환값으로 사용
- 자기참조 구조체 (연결 리스트)
- 구조체 멤버 정렬 (Memory Alignment)
- 비트필드 구조체
- 공용체 (Union)

**주요 개념**

**구조체 기본**
```c
typedef struct USERDATA {
    int age;
    char name[32];
    char phone[32];
} USERDATA;

// 선언 및 초기화
USERDATA user = {20, "김가인", "1234"};

// 멤버 접근
user.age = 30;
strcpy(user.name, "이나인");
```

**구조체 포인터**
```c
USERDATA *ptr = (USERDATA *)malloc(sizeof(USERDATA));
ptr->age = 25;  // (*ptr).age와 동일
strcpy(ptr->name, "박다인");
free(ptr);
```

**Call by Value vs Call by Reference**
```c
// 비효율: 전체 구조체 복사
USERDATA GetData(void) {
    USERDATA user = {20, "홍길동", "1234"};
    return user;  // 복사 발생
}

// 효율적: 포인터로 직접 수정
void GetData(USERDATA *user) {
    scanf("%d", &(user->age));
    fgets(user->name, 32, stdin);
}
```

**자기참조 구조체 (연결 리스트)**
```c
typedef struct USERDATA {
    char name[32];
    char phone[32];
    struct USERDATA *next;  // 자기 자신을 가리키는 포인터
} USERDATA;

// 연결 리스트 구성
userlist[0].next = &userlist[1];
userlist[1].next = &userlist[2];

// 순회
USERDATA *curr = &userlist[0];
while (curr != NULL) {
    printf("%s\n", curr->name);
    curr = curr->next;
}
```

**메모리 정렬 (Structure Padding)**
```c
typedef struct {
    char ch;   // 1 byte
    int age;   // 4 bytes
} USERDATA;

// 예상: 5 bytes
// 실제: 8 bytes (가장 큰 멤버 크기의 배수로 정렬)

// 1바이트 정렬 강제
#pragma pack(push, 1)
typedef struct {
    char ch;
    int age;
    double data;
} MYDATA;  // 실제 13 bytes
#pragma pack(pop)
```

**비트필드 구조체**
```c
typedef struct {
    unsigned char main : 1;   // 1비트
    unsigned char left : 2;   // 2비트
    unsigned char right : 3;  // 3비트
    unsigned char top : 2;    // 2비트
} DATAFLAG;  // 총 1바이트 사용
```

**공용체 (Union)**
```c
typedef union {
    int address;        // 4 bytes
    short data[2];      // 4 bytes
    unsigned char addr[4];  // 4 bytes
} IP_ADDR;  // 실제 크기: 4 bytes (가장 큰 것 하나)

// 모든 멤버가 같은 메모리 공유
IP_ADDR ip;
ip.address = 0x41424344;
printf("%c", ip.addr[0]);  // 'D' (리틀 엔디안)
```

---

### Chapter 14. 파일 입출력

**학습 내용**
- 텍스트/바이너리 파일 열기, 닫기
- 파일 읽기/쓰기 함수들
- 파일 포인터 제어
- 버퍼 관리

**주요 개념**

**파일 열기/닫기**
```c
FILE *file = fopen("test.txt", "w");  // 쓰기 모드
if (file == NULL) {
    puts("ERROR: Failed to open file");
    return 1;
}
fclose(file);

// 여러 파일 한번에 닫기
int closed = _fcloseall();
```

**파일 모드**
- `"r"`: 읽기
- `"w"`: 쓰기 (덮어쓰기)
- `"a"`: 추가 (append)
- `"rb"`, `"wb"`: 바이너리 모드

**텍스트 파일 입출력**
```c
// fprintf, fscanf
fprintf(file, "%s\n", "Hello World");
fscanf(file, "%d %s", &data, buffer);

// fputc, fgetc
fputc('A', file);
char ch = fgetc(file);

// fputs, fgets
fputs("Test string", file);
fgets(buffer, sizeof(buffer), file);  // 한 줄 읽기
```

**바이너리 파일 입출력**
```c
typedef struct {
    char name[16];
    char phone[16];
} DATA;

DATA data = {"Insung", "1234-5678"};

// 쓰기
fwrite(&data, sizeof(DATA), 1, file);

// 읽기
fread(&data, sizeof(DATA), 1, file);
```

**파일 포인터 제어**
```c
// 파일 크기 구하기
fseek(file, 0, SEEK_END);  // 끝으로 이동
long size = ftell(file);   // 현재 위치 = 파일 크기
fseek(file, 0, SEEK_SET);  // 처음으로 되돌리기

// SEEK_SET: 파일 시작
// SEEK_CUR: 현재 위치
// SEEK_END: 파일 끝
```

**버퍼 관리**
```c
fflush(stdin);  // 입력 버퍼 비우기
```

**연습문제 하이라이트**
- 파일 복사 프로그램 (텍스트/바이너리)
- 복사 진행률 표시 (백분율)
- 4KB 단위 버퍼 처리

---

## 2026-01-14

### Chapter 15. 변수와 상수 고급

**학습 내용**
- `const` 형한정어
- 상수형 포인터
- 심볼릭 상수 (`#define`)
- `volatile` 형한정어
- `extern` 외부 변수
- `typedef` 형 재선언
- `enum` 열거형 상수

**주요 개념**

**const 활용**
```c
// 상수 변수
const int CUTOFF = 70;

// 상수형 포인터 (가리키는 대상이 상수)
const int *ptr = &data;
// *ptr = 20;  // ERROR: 값 수정 불가
ptr = NULL;    // OK: 포인터 자체는 변경 가능

// 포인터 상수 (포인터 자체가 상수)
int * const ptr = &data;
*ptr = 20;     // OK: 값 수정 가능
// ptr = NULL; // ERROR: 포인터 변경 불가
```

**함수 매개변수에 const 사용**
```c
void PrintString(const char *str) {
    // str[0] = 'A';  // ERROR: 수정 불가
    puts(str);  // 읽기만 가능
}
```

**심볼릭 상수**
```c
// #define: 전처리 단계에서 치환
#define MAXLENGTH 32
char name[MAXLENGTH];  // 배열 크기로 사용 가능

// const: 변수이므로 배열 크기로 사용 불가 (C89 기준)
const int SIZE = 10;
// char arr[SIZE];  // 일부 컴파일러에서 에러
```

**volatile**
```c
// 컴파일러 최적화 방지
volatile int sensor_data = 0;

// Release 모드에서도 항상 실행
for (int i = 0; i < 100; ++i)
    sensor_data = 10;  // 최적화로 제거되지 않음
```

**extern 외부 변수**
```c
// file1.c
int g_counter = 0;
void InitCounter(int data) { g_counter = data; }

// file2.c
extern int g_counter;  // 선언 (정의는 file1.c에)
int main(void) {
    printf("%d\n", g_counter);
}
```

**typedef**
```c
typedef unsigned int UINT;
typedef const char* STR;

UINT age = 25;
STR message = "Hello";
```

**열거형 상수 (enum)**
```c
typedef enum {
    MOVE,    // 0
    JUMP,    // 1
    ATTACK   // 2
} ACTION;

typedef enum {
    RED = 100,  // 명시적 값 지정
    GREEN,      // 101
    BLUE        // 102
} COLOR;

void PrintColor(COLOR color) {
    switch (color) {
        case RED: puts("Red"); break;
        case GREEN: puts("Green"); break;
        case BLUE: puts("Blue"); break;
    }
}
```

---

### Chapter 16. 전처리기

**학습 내용**
- 매크로 함수
- 매크로 특수 연산자 (`#`, `##`)
- 조건부 컴파일
- 빌드 설정 분기

**주요 개념**

**매크로 함수**
```c
// 함수 호출 오버헤드 제거
#define ADD(a, b) ((a) + (b))

// 주의: 괄호 필수!
#define WRONG(a, b) a + b
printf("%d\n", WRONG(3, 4) * 2);  // 3 + 4 * 2 = 11

#define RIGHT(a, b) ((a) + (b))
printf("%d\n", RIGHT(3, 4) * 2);  // (3 + 4) * 2 = 14
```

**매크로 특수 연산자**
```c
// # : 문자열화 (Stringification)
#define STRING(x) #x
printf("%s\n", STRING(data));  // "data"

// ## : 토큰 붙이기 (Token Pasting)
#define PASTER(a, b) a##b
int data = 10;
printf("%d\n", PASTER(da, ta));  // data = 10
```

**조건부 컴파일**
```c
// 1. ifdef
#define _DEBUG

#ifdef _DEBUG
    #define MODE "Debug Mode"
#else
    #define MODE "Release Mode"
#endif

// 2. 인코딩 선택
#define _UNICODE

#ifdef _UNICODE
    typedef wchar_t CHAR;
    #define _(string) L##string
    #define PRINT wprintf
#else
    typedef char CHAR;
    #define _(string) string
    #define PRINT printf
#endif

CHAR str[16] = _("Hello");
PRINT(_("%s\n"), str);
```

---

### Chapter 17. 함수 고급

**학습 내용**
- 컴파일러 최적화
- 인라인 함수 (`__inline`)
- 함수 호출 규약 (Calling Convention)
- 함수 포인터
- 콜백 함수 (Callback)
- 가변 인자
- 정적 라이브러리

**주요 개념**

**인라인 함수**
```c
// Release 모드에서 자동 인라인 확장 가능
int Add(int a, int b) {
    return a + b;
}

// 강제 인라인
__inline int NewAdd(int a, int b) {
    return a + b;
}
```

**함수 호출 규약**
```c
// __cdecl (C 기본): Caller가 스택 정리
int __cdecl Add(int a, int b);

// __stdcall: Callee가 스택 정리 (Windows API 표준)
int __stdcall GetMax(int a, int b, int c);

// __fastcall: 레지스터 사용 (일부 매개변수)
int __fastcall Multiply(int a, int b);
```

**함수 포인터**
```c
// 함수 포인터 선언
int (*funcPtr)(int, int, int) = GetMax;

// 사용
int result = funcPtr(1, 3, 2);
```

**콜백 함수**
```c
// qsort()의 비교 함수
int Compare(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

int main(void) {
    int list[5] = {30, 10, 40, 50, 20};
    // qsort가 Compare를 역호출 (callback)
    qsort(list, 5, sizeof(int), Compare);
}
```

**가변 인자**
```c
#include <stdarg.h>

int GetMax(int count, ...) {
    va_list args;
    va_start(args, count);
    
    int max = va_arg(args, int);
    for (int i = 1; i < count; ++i) {
        int data = va_arg(args, int);
        if (data > max) max = data;
    }
    
    va_end(args);
    return max;
}

// 사용
GetMax(3, 40, 20, 10);
GetMax(5, 40, 20, 10, 30, 45);
```

**정적 라이브러리**
```c
// LibTest.h
#pragma once
void PrintData(int);
void PrintString(const char *);

// LibTest.c
void PrintData(int data) { printf("%d\n", data); }
void PrintString(const char *str) { printf("%s\n", str); }

// 컴파일: gcc -c LibTest.c -o LibTest.o
// 라이브러리 생성: ar rcs LibTest.a LibTest.o
// 사용: gcc TestApp.c LibTest.a -o TestApp.exe
```

---

## 2026-01-15

### Python 프로그래밍 시작

**새로운 Repository 생성**
- `python_programming_practice` 저장소 생성
- Jupyter Notebook을 이용한 학습 시작

### Chapter 02. 자료형 - 문자열 (String)

**학습 내용**
- 문자열 생성 방법 (4가지)
- 문자열 연산 (덧셈, 곱셈, 길이)
- 인덱싱과 슬라이싱
- 문자열 포매팅 (%, `.format()`, f-string)
- 문자열 관련 함수들

**주요 개념**

**문자열 생성**
```python
# 4가지 방법
s1 = "Hello World"
s2 = 'Python is fun'
s3 = """Life is too short"""
s4 = '''You need python'''

# 여러 줄
multiline = """
Life is too short.
You need python.
"""
```

**문자열 연산**
```python
head = "Python"
tail = " is fun"
print(head + tail)  # Python is fun

print("=" * 50)  # 구분선 출력
print(head * 3)  # PythonPythonPython

len("Hello")  # 5
```

**인덱싱과 슬라이싱**
```python
s = "Life is too short, You need Python"

s[0]    # 'L'
s[-1]   # 'n'
s[5:7]  # 'is'
s[19:]  # 'You need Python'
s[:17]  # 'Life is too short'
s[:]    # 전체

# 문자열은 immutable
# s[1] = 'a'  # ERROR
s[:1] + 'a' + s[2:]  # 'Lafe...'  새로운 문자열 생성
```

**문자열 포매팅**
```python
# 1. % 방식
"I eat %d apples" % 3
"I ate %d apples, so I was sick for %s days" % (10, "three")

# 2. format() 메서드
"I eat {0} apples".format(3)
"I ate {number} apples, so I was sick for {day} days".format(
    number=10, day="three"
)

# 정렬
"{0:<10}".format("hi")   # 왼쪽 정렬
"{0:>10}".format("hi")   # 오른쪽 정렬
"{0:^10}".format("hi")   # 가운데 정렬
"{0:=^10}".format("hi")  # ====hi====

# 소수점
"{0:0.4f}".format(3.141592)  # 3.1416
"{0:10.4f}".format(y)        # 공백 포함 10자리

# 3. f-string (Python 3.6+)
name = "홍길동"
age = 30
f"나의 이름은 {name}이고, 나이는 {age}세입니다"
f"내년엔 {age + 1}세가 됩니다"

# 딕셔너리 사용
d = {'name': '김가인', 'age': 30}
f"이름: {d['name']}, 나이: {d['age']}"

# 정렬
f"{'hello':<10}"  # 왼쪽
f"{'hello':>10}"  # 오른쪽
f"{'hello':^10}"  # 가운데
f"{'hello':=^10}" # ==hello===
```

**문자열 함수**
```python
s = "Python is the best choice"

# 개수 세기
"hobby".count('b')  # 2

# 인덱스 찾기
s.find('b')   # 14 (못 찾으면 -1)
s.index('b')  # 14 (못 찾으면 ValueError)

# 문자열 삽입
",".join("abcd")  # "a,b,c,d"
",".join(['a', 'b', 'c'])  # "a,b,c"

# 대소문자 변환
"Hi, How are you?".upper()  # "HI, HOW ARE YOU?"
"Hi, How are you?".lower()  # "hi, how are you?"

# 공백 제거
"   hi   ".lstrip()   # "hi   "
"   hi   ".rstrip()   # "   hi"
"   hi   ".strip()    # "hi"

# 문자 제거
"*****hi*****".strip('*')  # "hi"

# 문자열 대체
"Life is too short".replace("Life", "My arm")

# 문자열 나누기
"Life is too short".split()      # ['Life', 'is', 'too', 'short']
"a:b:c:d".split(':')             # ['a', 'b', 'c', 'd']
```

**Python vs C 문자열 차이점**
- Python: 문자열은 immutable (수정 불가)
- C: 문자 배열이므로 직접 수정 가능
- Python: 인덱싱/슬라이싱이 매우 간편
- C: 포인터 연산 필요

---

## 학습 정리

### C 프로그래밍 핵심 개념

**1. 메모리와 포인터**
- 포인터는 주소를 저장하는 변수
- 배열 이름 = 주소 상수 (첫 번째 요소의 주소)
- 동적 할당: `malloc`/`calloc` → `free` 필수
- 메모리 누수 방지가 핵심

**2. 함수 설계**
- Call by Value: 값 복사 (안전, 비효율)
- Call by Reference: 주소 전달 (효율, 주의 필요)
- 배열/구조체는 포인터로 전달
- 동적 할당 메모리는 누가 해제할지 명확히

**3. 구조체**
- 연관된 데이터를 묶어서 관리
- 메모리 정렬(padding) 이해 필요
- 자기참조 구조체 → 자료구조 구현 기반

**4. 파일 입출력**
- 텍스트 모드 vs 바이너리 모드
- 버퍼 개념 이해
- 파일 포인터로 위치 제어

**5. 고급 기능**
- `const`: 상수화, 실수 방지
- 매크로: 전처리 단계 치환
- 조건부 컴파일: 빌드 설정 분기
- 함수 포인터: 콜백, 유연한 설계

### Python 시작

**장점**
- 간결한 문법
- 문자열 처리가 매우 강력
- 메모리 관리 자동

**C와의 차이**
- 동적 타이핑 (타입 선언 불필요)
- 문자열 immutable
- 인덱싱/슬라이싱 직관적
- f-string으로 포매팅 간편

### 다음 학습 예정

**Python 프로그래밍**
- 기본 자료형 (리스트, 튜플, 딕셔너리)
- 제어문과 반복문
- 함수와 모듈
- 객체지향 프로그래밍

---